#include <iostream>

int Min(int a, int b, int c) {
  if (a < b) {
    if (a < c) {
      return a;
    }
    return c;
  }
  if (b < c) {
    return b;
  }
  return c;
}

int MagicCalculus(int n) {
  if (n == 1) {
    return 0;
  }
  if (n == 2 || n == 3) {
    return 1;
  }
  /*
  Решение ̶с̶п̶и̶з̶ж̶е̶н̶о̶ добросовестно найдено на просторах интернета, адаптировано, разобрано и объяснено.
  Нам нужно найти минимальное кол-во действий, чтобы превратить число 1 в число n.
  Если n == 1, то нам ничего предпринимать не надо, у нас итак 1.
  Если n == 2 || n == 3, то мы можем попасть туда за 1 действие (1 * 3 для n == 3; 1 * 2 или 1 + 1 для n == 2)
  Если n == 4, то мы можем получить n несколькими путями, из которых нам нужно выбрать самый короткий:
  - 1 + 1 + 1 + 1
  - 1 * 2 * 2
  - 1 * 3 + 1
  Следовательно, мы можем создать массив с длинной маршрутов, просчитаных ранее и использовать их для нахождения финального ответа.
  В n мы можем попасть через несколько путей.
  - Из позиции n - 1 в позицию n
  - Из n / 2 в n (при n % 2)
  - Из n / 3 в n (при n % 3)
  Если мы знаем кол-во действий для вышеописанных вариантов, то мы можем найти минимальное кол-во действий для n, найдя минимальное
  из вышеприведённых и добавив 1 (т.к. совершили ещё одно действие)
  */
  int answ = 0;
  int* dynamic = new int[n];
  dynamic[0] = 0;
  dynamic[1] = dynamic[2] = 1;
  for (int i = 3; i < n; ++i) {  // i + 1 - число, для которого ищем минимальное кол-во действий
    if ((i + 1) % 2 == 0 && (i + 1) % 3 == 0) {
      dynamic[i] = Min(dynamic[i - 1], dynamic[i / 2], dynamic[i / 3]);
    } else if ((i + 1) % 2 == 0) {
      dynamic[i] = Min(dynamic[i - 1], dynamic[i - 1], dynamic[i / 2]);
    } else if ((i + 1) % 3 == 0) {
      dynamic[i] = Min(dynamic[i - 1], dynamic[i - 1], dynamic[i / 3]);
    } else {
      dynamic[i] = dynamic[i - 1];
    }
    ++dynamic[i];
  }
  answ = dynamic[n - 1];
  delete[] dynamic;
  return answ;
}

int main() {
  int n = 0;
  std::cin >> n;
  std::cout << MagicCalculus(n);
  return 0;
}
